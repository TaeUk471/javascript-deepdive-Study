# 8) 제어문

---

<aside>
💡 제어문 : 조건문 & 반복문

</aside>

⇒ 코드의 실행을 인위적으로 제어 So, 가독성을 해치는 단점 → forEach, map, filter, reduce등으로 해소

# 8.1) 블록문(block statement, compund statement)

---

⇒ 0개 이상의 문을 중괄호로 묶은 것

⇒ 하나의 실행 단위

```jsx
//블록문 : 단독으로도 사용 가능하다.
{
	let foo = 10;
}

// 일반적으로 제어문, 함수선언문에 많이 사용된다.
// 제어문
let x = 1;
if (x < 10) {
	x++;
}

// 함수 선언문
function sum(a, b) {
	return a + b;
}
```

# 8.2) 조건문(conditional statement)

---

 조건식(conditional expression)의 결과에 따라 블록문을 실행

## ☝️조건문 2개

8.2.1 if …else

```jsx
// else와 else if는 선택사항

if (조건식1) {
	//조건식1 true -> 코드블록 실행
} else if (조건식2) {
	//조건식2 ture -> 코드블록 실행
} else {
	//조건식1 -> false, 조건식2 -> false면, 코드블록 실행
}

// 블록문내의 문 한개 -> 중괄호 생략 가능
let num = 2;
let kind;

if (num > 0)    kind = '양수';
else if (num <0)    kind ='음수';
else    kind = '영';
console.log(kind); //양수
```

대부분의 if …else문은 삼항 조건 연산자로 변경 가능

<aside>
💡 삼항 조건 연산자 : 값으로 평가 → 변수 할당 가능
if …else문 : 값으로 평가❌ → 변수 할당 ❌

</aside>

✅ 값을 변수에 할당하는 경우 : 삼항 조건 연산자 활용 (가독성👍)

✅ 여러줄의 문이 필요한 경우 : if …else문 활용 (가독성👍)

8.2.2 switch 문

```jsx
switch (표현식) {
	case 표현식1:
		표현식 === 표현식1 : 실행;
	break;  // switch문 종료
	case 표현식2:
		표현식 === 표현식2 : 실행;
		break;
	default:
		switch문과 일치하는 case문이 없을 때, 실행
}
```

⇒ switch문은 불리언 값보다 문자열이나, 숫자 값을 표현식으로 사용하는 경우가 많음

⇒ 논리적 참, 거짓 < 다양한 상황(case)에 따라 실행할 경우 사용

### ✅ 폴스루(fall through)

⇒ 한번 값의 할당이 이러나면 끝까지 모든 case문을 실행

⇒ So, 모든 case에 break문을 활용하여 switch문을 종료시켜 줘야함 (단, default는 일반적으로 생략)

<활용>

```jsx
let year = 2000;
let month = 2;
let days = 0;

switch(month){
	case 1: case 3: case 5: case 7: case 8: case 10: case 12:
		days = 31;
		break;
	case 4: case 6: case 9: case 11:
		days = 30;
		break;

```

Q) 둘중 뭘쓰지?

✅ if ..else문으로 해결 가능 → if …else문 사용

✅ 조건식이 많은 경우 → switch문 사용

A) 가독성에 따라 판단!

# 8.3) 반복문(loop statement)

---

⇒ 조건식이 참인 경우 코드 블록을 실행 ( 조건식이 거짓일 때까지 반복 )

### ☝️반복문 3개

8.3.1 for문

```jsx
for(변수 선언|할당; 조건식; 증감식) {
	조건식이 참 -> 실행;
}

for (let i = 0; i <2 ; i++) { // 주로 변수 i사용 (iteration)
	console.log(i)
}

//중첩 사용 가능
for (let i = 1; i <= 6; i++) {
	for (let j = 1; j <=6; j++) {
		if (i + j === 6) console.log(`[${i}, ${j}]`);
	}
}
```

8.3.2 while문

```jsx
//기본 형식
while (condition) {
	statement
}

let count = 0;

// 조건식이 거짓일 때 까지 반복 실행
while (count <3) {
	console.log(count); 
	count++;
}

// 조건식 참 -> 무한루프 -> 탈출(break문)
let count = 0;
while (true) {
	console.log(count);
	count++;
	if (count === 3) break;
}
```

8.3.3 do… while문

→ 코드 블록을 먼저 실행 후 조건식 평가 (반드시 한번 이상 실행)

```jsx
//기본 형식
do {
	statement
} while (condition);

let count = 0;
do {
	console.log(count); // 0 1 2
	count ++;
} while (count<3);
```

# 8.4) break문

---

❌ 코드 블록을 탈출한다

✅ 레이블분 & 반복문 & switch문의 코드블록을 탈출한다

레이블문(label statement)

→ 식별자가 붙은 문

```jsx
foo: {
	console.log(1);
}

// 중첩 for문에서 외부 for문 탈출시 사용
outer: for (let i = 0 ; i < 3; i++){
	for (let j = 0 ; j < 3 ; j++) {
	if (i + j === 3) break outer; // outer가 붙은 for문 탈출
	console.log(`inner [${i}, ${j}]`);
	}
}
```

<aside>
💡 유용하지만, 일반적으로 권장❌ (가독성😭, 오류 발생 가능성👆)

</aside>

# 8.5) continue문

---

코드 블록의 실행을 중단하고 다음 반복문을 진행한다 (반복문 탈출❌)

```jsx
let string = 'Hello World';
let search = 'l';
let count = 0;

let (let i = 0 ; i < string.length; i++) {
	if (string[i] !== search) continue;
	count ++;
}

console.log(count); //3

// * 참고 *
const regexp = new RegExp(search, 'g')' //정규표현식 학습 필요
console.log(string.match(regexp).length); //3
```