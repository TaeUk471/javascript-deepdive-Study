# 4) 변수

## 4.1 변수란 무엇인가? 왜 필요한가?

### 변수 (variable)

⇒  하나의 값을 저장하기 위해 확보한 메모리 공간 자체 // 메모리 공간을 식별하기 위해 붙인 이름

⇒ 값의 위치를 가리키는 상징적인 이름

⇒ 개발자의 직접적인 메모리 제어 허용❌ So, 변수를 사용	

```jsx
let result = 10 + 20; // result(변수 이름)에 30(변수 값)이 저장된다.
```

<aside>
💡 컴퓨터 | CPU : 연산 | 메모리: 데이터를 기억

</aside>

### 메모리 (memory)

⇒ 데이터를 저장할 수 있는 메모리 셀의 집합체

⇒ 메모리 셀 하나의 크기는 1바이트 (8비트)

⇒ 1바이트 단위로 데이터를 저장(write) & 읽기(read)

## 4.1) 식별자

### 식별자(identifier)

⇒ 변수의 이름 : 어떤 값을 구별해서 식별할 수 있는 고유한 이름 

⇒ 값이 저장되어 있는 *메모리주소*를 기억 ( 값을 저장 ❌) | ✅ 식별자 : 메모리 주소에 붙인 이름

⇒ 값이 저장되어 있는 메모리 주소와 *매핑관계* | 매핑 정보도 메모리에 저장

## 4.3) 변수 선언

### 변수 선언(variable declaration)

⇒ 변수를 생성

⇒ 메모리 공간을 확보(allocate), 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)

⇒ 선언에 의해 확보된 메모리는 release되기 전까지 보호

⇒ *`var`, `let`, `const`를 사용하여 선언 ( *변수를 사용하려면 반드시 선언해야 함)*

```jsx
let score; // 변수 선언문
```

⇒ 변수에 값을 할당하지 않으면 *undefined 가 자동으로 할당되어 초기화 된다.*

- 변수 선언의 2단계
    
    ☝️ 선언단계 : ”변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다“
    
    ☝️ 초기화 단계 : ”값을 저장하기 위한 메모리 공간을 확보, 암묵적으로 undefined를 할당해 초기화“
    
- 변수 이름은 어디에 등록되는가?
    
    모든 식별자는 *실행 컨텍스트(execution context)에 등록 된다.*
    
    - 실행 컨텍스트(execution context)
        - 자바스크립트 엔진이 소스코드를 평가하고, 실행하기 위해 필요한 환경을 제공, 코드의 실행결과를 실제로 관리하는 영역
        - 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.
        - 변수 이름과 값 - 키(key)/값(value) 형식인 객체로 등록되어 관리

## 4.4) 변수 선언의 실행시점과 변수 호이스팅

```jsx
console.log(score);
let score; // 변수 선언문
```

<aside>
💡 ReferenceError가 발생하지 않고 undefined가 출력된다.

- Why❓
    
    변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점(runtime)이 아닌
    
    그 이전 단계에서 먼저 실행되기 때문이다.
    
    - 소스코드를 순차적으로 실행전 소스코드의 평가 과정을 거친다.
    - 평가 과정에서 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행 한다.
    - 이 후 모든 선언문을 제외한 소스코드를 한 줄씩 순차적으로 실행한다.
</aside>

### 🙋‍♀️변수 호이스팅(variable hoisting)이란?

⇒ 변수 선언문이 코드의 선두로 올려진 것 처럼 동작하는 자바스크립트의 특징

## 4.5) 값의 할당

```jsx
let score; //변수 선언
score = 80; // 값의 할당

let score = 80; //변수 선언 & 값의 할당
```

<aside>
💡 선언과 할당을 하나의 문(statement)로 단축해도 선언과 할당 2개의 문으로 나누어 실행 된다.

- 이게 무슨 의미가 있는데❓
    
    ❗️변수의 선언은 런타임 이전에 실행 되지만, 값의 할당은 런타임에 실행된다.
    
    ```jsx
    console.log(score); // undefined
    let score;
    score = 80
    console.log(score); // 80
    //==============================
    
    console.log(score); // undefined
    let score = 80
    console.log(score); // 80
    ```
    
</aside>

Q) 값을 할당할 때 이전 값 (undefined)가 저장되어 있던 메모리 공간을 지우고 값을 할당? 

A) ❌ ⇒ 새로운 메모리 공간을 확보하고, 그곳에 새로운 값을 할당

## 4.6) 값의 재할당

```jsx
let score = 80;
score = 90;
```

### ✅값의 재할당 : 기존 메모리의 값 지우고 할당 하는 것이 아닌 새로운 공간 확보 후 할당

- 그럼 이전 메모리들은 어떻게 되는거지?? ❗️가비지 콜렉터(garbage collector)
    
    ⇒ 가비지 콜렉터는 할당(allocate)한 메모리 공간을 검사하여 더이상 사용되지 않는 메모리를 release 한다.
    
    ⇒ 더이상 사용되지 않는 메모리 : 어떤 식별자도 참조하지 않는 메모리 공간
    
    ⇒ 가비지 콜렉터로 인해 메모리 누수(memory leak)이 방지된다.
    
    ⇒ *자동으로 해제되기 때문에, 언제 해제될지는 알 수 없다.
    
- unmanaged language 🆚 managed language
    
    ☝️언매니지드 언어(c언어) 개발자의 직접적인 메모리 제어 허용 👌 (low-level 메모리 제어기능)
    
    ⇒ 역량에 따라 최적의 성능 확보 가능 BUT, 치명적 오류 생산 가능선 높음
    
    ☝️매니지드 언어(자바스크립트) 개발자의 직접적인 메모리 제어 허용❌
    
    ⇒ 가비지 콜렉터가 수행 | 생산성확보 가능 BUT, 성능 면에서 손실
    

<aside>
💡 변수(variable) : 변경할 수 있는 값 🆚 상수(constant) : 변경할 수 없는 값

</aside>

## 4.7) 식별자 네이밍 규칙

---

### 네이밍 규칙

- 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러($) 포함 가능 ✅
- 단, 숫자로 시작 불가능 ❌ ( 문자, 언더스코어(_), 달러($) 로 시작해야 한다.)
- 예약어 식별자 불가능 ❌
    - 예약어: 프로그래밍 언어에서 사용되거나 사용될 예정인 단어

### 네이밍 컨벤션

```jsx
let firstName // 카멜 케이스(camelCase)

let first_name // 스네이크 케이스(snake_case)

let FristName // 파스칼 케이스(PascalCase)

//헝가리언 케이스(typeHungarianCase)
let strFirstName // type + identifier
let $elem = document.getElementById('myId'); // DOM 노드
let observable$ = fromEvent(document, 'click'); // RxJS 옵저버블
```

<aside>
💡 자바스크립트에서 일반적으로 사용되는 네이밍 컨벤션
 변수, 함수 : 카멜케이스
 생성자 함수, 클래스 : 파스칼 케이스

</aside>