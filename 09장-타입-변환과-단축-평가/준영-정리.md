# 9) 타입 변환과 단축평가

---

# 9.1) 타입 변환이란?

☝️ 개발자의 의도에 따른 타입 변환 → 명시적 타입 변환 | 타입 캐스팅

☝️ 개발자의 의도와 상관 없는 타입 변환→ 암묵적 타입 변환 | 타입 강제 변환

두가지 타입변환

9.2) 암묵적 타입변환 | 타입 강제 변환

⇒ 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환

9.2.2 숫자 타입으로 변환

```jsx
1 - '1' // 0
1 * '10' // 10
1 / 'one' // NaN
'1' > 0 // true

+'' // 0
+'0' // 0
+'1' // 1
+'string' // NaN

+true // 1
+false // 0

+null // 0
+undefined // NaN

+Symbol() // TypeError: Cannot convert a symbol value to a number

+{} // NaN 
+[]  // 0 배열은 비어있으면 0반환!
+[10, 20] NaN
+(function(){})

```

9.2.1 문자열 타입으로 변환

```jsx
0 + '' // "0"
-0 + '' // "0"
1 + '' // "1"
-1 + '' // "-1"
NaN + '' // "NaN"
Infinity + '' // "Infinity"
-Infinity + '' // "-Infinity"

true + '' // "true"
false + '' // "false"
null + '' // "null"
undefined + '' // "undefined"

//
(Symbol()) + '' // TypedError : Cannot convert a Symbol value to a string
({}) + '' // "[obejct Object]"
Math + '' // "[object Math]"
[] + '' // ""
[10, 20] + '' // "10,20"
(function(){}) + '' // "function(){}"
Array + '' // "function Array() { [native code] }"

```

9.2.3 불리언 타입으로 변환

false로 평가되는 값

- false
- undefined
- null
- 0, =0
- NaN
- ‘’

9.3) 명시적 타입 변환 | 타입 캐스팅

개발자의 의도에 따라 명시적트로 타입을 변경

9.3.1 문자열 타입으로 변환

```jsx
// 1. String생성자 함수를 new연산자 없이 호출
String(1);
String(NaN);
String(Infinity);
String(true);
String(false);

// 2. Object.prototype.toString메서드 사용
(1).toString();
(NaN).toString();
(Infinity).toString();
(true).toString();
(false).toString();

// 3. 문자열 연결 연산자를 이용
1 + '';
NaN + '';
Infinity + '';
true + '';
false + '';
```

9.3.2 숫자 타입으로 변환

```jsx
// 1. Number 생성자 함수를 new 연산자 없이 호출
Number('0');
Number('-1');
Number('10.53');
Number(true); // 1
Number(false); 0

// 2. parseInt, parseFloat 함수를 사용
parseInt('0')
parseInt('-1')
parseInt('10.53')

// 3. + 단항 산술 연산자를 이용
+'0';
+'-1';
+'10.53';
+true;
+false;

4. * 산술 연산자를 이용
'0' * 1
'-1' * 1
'10.53' * 1
true * 1; // 1
false * 1 // 0

```

9.3.3 불리언 타입으로 변환

```jsx
1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
Boolean('x');  // true
Boolean('');  //false
Boolean('false');  //true
Boolean(0); // false
Boolean(1);  // true
Boolean(NaN);  //false
Boolean(Infinity);  //true
Boolean(null);  //false
Boolean(undefined);  //false
Boolean({});  //true
Boolean([]);  //true

2. ! 부정 논리 연산자를 두 번 사용하는 방법
!!'x'
!!'' 
!!'false'
```

# 9.4 ) 단축평가(short-circuit evaluation)

---

## 9.4.1 논리연산자를 사용한 단축평가

<aside>
💡 논리합(||)과 논리곱(&&) 연산자의 결과는 불리언 값이 아닐 수도 있다!

</aside>

```jsx
// 둘다 참일 때,
'Cat' && 'Dog' // Dog : 논리 연산의 결과를 결정한 피연산자('Dog') 반환
'Cat' || 'Dog' // Cat : 논리 연산의 결과를 결정한 피연산자('Cat') 반환
```

### 단축평가 : 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 과정을 생략

⇒ 논리 연산의 결과를 결정하는 피연산자를 타입 변환 없이 그대로 반환

| 단축 평가 표현식 | 평가 결과 |
| --- | --- |
| true || anything | true |
| false || anything | anything |
| true && anything | anything |
| false && anything | false |

```jsx
'Cat' || 'Dog' // 'Cat'
false || 'Dog' // 'Dog'
'Cat' || false // 'Cat'

'Cat' && 'Dog' // 'Dog'
false && 'Dog' // false
'Cat' && false // false
```

### 단축평가의 사용

*단축 평가를 통한 if문 대체*

```jsx
let done = true;
let message = '';

if (done) message = '완료'
message = done && '완료'; //done이 참이면 '완료' 할당

done = false;
message = done || '미완료'; //done이 거짓이면 '미완료'할당
```

*객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때*

null 또는 undefined인 경우 프로퍼티를 참조하면, 타입 에러가 발생 → 프로그램 종료

```jsx
let elem = null;
let value = elem.value; // TypeError: Cannot read property 'value' of null

let elem = null;
let value = elem && elem.value; // null
```

<aside>
💡 Q) 만약, 객체가 아니면 어떻게 되지???
A) undefined가 출력된다.

</aside>

*함수 매개변수에 기본값을 설정할 때*

매개변수에 인수를 전달하지 않으면 undefined 할당 → 단축 평가를 통한 방지

```jsx
function getStringLength(str) {
	str = str || '';
	return str.length;
}

getStringLength();  //0
getStringLEngth('hi');  //2

//ES6 기본값 설정
function getStringLength(str = '') {
	return str.length;
}

getStringLength();  // 0
getStringLength('hi');  // 2
```

## 9.4.2 옵셔널 체이닝 연산자(optional chaining)

⇒ 좌항의 피연산자가 null | undefined인 경우 undefined를 반환, 아닌 경우 프로퍼티 참조(ES11 도입)

```jsx
// ?. : 옵셔널 체이닝 연산자
let elem = null
let value = elem?.value
console.log(vlaue) // undefined
```

```jsx
// * 옵셔널 체이닝과 단축평가의 차이점 *
let elem = null
let value = elem && elem.value // null
let value = elem?.value // undefined

let str = '';
let length = str && str.length; // ''
let length = str?.length // 0
// Why? 좌항 피연산자의 Falsy값이 0이나 ''인경우 객체로 평가되는 경우도 있기 때문이다.
// 또한 옵셔널 체이닝은 null과 undefined에만 유효하다.
```

## 9.4.3 null 병합 연산자(nullish coalescing)

⇒ 좌항의 피연산자가 null | undefined인 경우 우항 반환, 아닌 경우 좌항 반환

⇒ 변수에 기본값 설정 시 유용

```jsx
// ?? : null병합 연산자
let foo = null ?? 'default string'; // "default string"
let foo = undefined ?? 'default string'; // "default string"
```

```jsx
// *null 병합연산자와 단축평가의 차이점 *

let foo = '' || 'default string'; // "default string"
let foo = '' ?? 'default string'; // ""
// 단축평가: Falsy값 모두에 유효하다
// null병합연산자: null과 undefined에만 유효하다
```