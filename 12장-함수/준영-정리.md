# 12) 함수

---

# 12.1 함수란?

---

<aside>
💡 자바 스크립트에서 가장 중요한 핵심 개념!

</aside>

⇒ 수학에서의 함수 : 입력(input)을 받아 출력(output)을 내보내는 일련의 과정

⇒ 프로그래밍에서의 함수: 코드 블록 안에 일련의 과정(문)을 구현한 하나의 실행 단위

⇒ 함수는 정의 → 호출(call/ invoke) 의 과정으로 실행된다.

# 12.2 함수를 사용하는 이유

---

✔️ 코드의 재사용성: 함수는 몇번이든 호출 가능!

✔️ 유지보수 편의성 & 코드의 신뢰성: 코드의 중복 억제 및 재사용성 증가로 인한

✔️ 코드의 가독성 향상: 적절한 함수의 네이밍으로 인한

<aside>
💡 가독성이 좋은 코드가 좋은 코드!

</aside>

# 13.3 함수 리터럴

---

✔️ 자바스크립트에서의 함수: 객체 ⇒ 함수도 리터럴로 생성 가능

```jsx
var f = function add(x, y) { 
	return x + y;
};
```

### *함수와 일반객체의 차이*

- 함수는 호출이 가능
- 함수 객체만의 고유한 프로퍼티 존재

# 12.4 함수 정의

---

### 함수를 정의하는 4가지 방법

- 함수 선언문
    
    ```jsx
    function add(x,y){  // 함수 선언문의 함수 이름 생략 불가능 
    	return x + y;
    };
    ```
    
    자바스크립트 엔진이 암묵적으로 함수 이름을 식별자로 등록한다.
    
- 함수 표현식
    
    ```jsx
    var add = function (x, y){ // 함수 표현식의 함수 이름 생략 가능
    	return x + y;
    };
    ```
    
    add가 식별자로 사용된다.
    
- Function 생성자 함수
    
    ```jsx
    var add = new Function('x', 'y', 'return x + y');
    ```
    
- 화살표 함수(ES 6)
    
    ```jsx
    var add = (x, y) => x + y;
    ```
    
- 기명함수 vs 익명함수
    - 기명함수: 이름이 있는 함수
    - 익명함수: 이름이 없는 함수

### 함수 생성 시점과 함수 호이스팅

- 함수 선언문으로 정의한 함수
    - 함수 호이스팅 발생(런타임 이전에 실행)
    - undefined로 초기화X ⇒ 함수 객체로 초기화
- 함수 표현식으로 정의한 함수
    - 변수 호이스팅이 발생한다.
    
    ## 화살표 함수
    
    > function의 간략화버전
    외부 표현뿐만 아니라, 내부 동작도 간략화
    생성자 함수X, this 바인딩, arguments X, prototype X
    > 
    
    # 12.5 함수 호출
    
    식별자와 소괄호(함수 호출 연산자)를 이용하여 호출 한다.
    
    ```jsx
    function printHello() {
    	console.log("hello")
    }
    
    printHello() // 함수 호출 결과: Hello
    ```
    
    ### 12.5.1 매개변수와 인수
    
    매개변수
    
    - 함수 외부에서 함수 내부로 전달하는 인자
    - 매개변수의 스코프는 함수 내부
    - 매개변수와 인수의 개수는 체크하지 않는다.
    - 인수가 부족한 경우 매개변수에 undefined할당, 더 많은 경우 arguments 객체에 저장
    
    ```jsx
    function add(x,y){
    	return x + y;
    }
    console.log(add(2))
    console.log(add(2, 5, 10)
    ```
    
    ### 12.5.2 인수 확인
    
    오류에 상황에 대응하기 위하여 다음과 같은 방법들을 이용하여 확인이 가능하다.
    
    ```jsx
    function add(x, y){
    	if (typeof x !== 'number' || typeof y !== 'number'){
    		throw new TypeError('인수는 모두 숫자 값이어야 합니다.')
    	}
    }
    
    //혹은 다음처럼 초기값 할당 가능 
    function add(x, y){
    	a = a || 0;
    	b = b || 0;
    	c = c || 0;
    	return a + b + c;
    }
    
    //ES6
    function add(x = 0, y = 0){
    	return a + b;
    }
    ```
    
    ### 12.5.4 반환문
    
    반환문의 2가지 역할
    
    - 함수 실행을 중단시키고, 함수 몸체를 빠져나간다.
    - return뒤의 표현식을 평가하여 반환, 없을 시 undefined 반환
    - 반환문 생략시 암묵적으로 undefined 반환
    
    # 12.7 다양한 함수의 형태
    
    ### 12.7.1 즉시 실행 함수(IIFE)
    
    - 단 한번만 호출, 다시 호출 X
    - 익명 함수를 사용하는 것이 일반적
    
    ```jsx
    (function () {
    	var a = 3;
    	var b = 5;
    	return a * b;
    }());
    ```
    
    ### 12.7.2 재귀 함수
    
    - 자기 자신을 호출하는 함수
    - 반복처리를 위해서 사용
    - 탈출조건이 반드시 있어야 한다.
    - 탈출조건이 없을 경우 함수가 무한 호출되어 스택 오버플로가 발생
    
    ### 12.7.3 중첩 함수
    
    - 함수 내부에 정의된 함수
    - 외부 함수를 돕는 헬퍼 함수의 역할을 한다.
    - if나 for문등의 코드블록 안에서는 사용하지 말자.
    
    ### 12.7.4 콜백 함수
    
    - 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
    - 고차 함수: 콜백 함수를 전달받은 함수 or 함수를 반환하는 함수